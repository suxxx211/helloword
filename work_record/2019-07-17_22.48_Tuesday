# This document records daily work and other log infomation.

2019/7/17 22.48 Tuesday

.WORK_PLAN
    1.Mac暂时就这样，把超时打印去掉，最多4s，也是是usleep400000，10个循环。之后关闭upload，开始交给命令行显示。
    2.继续修改mirror模块，主要还是在软驱动index这里，做一个转换，按照思考的设计来。争取今天完成。
    
.STUDY_PLAN
    1.<8.30-8.50><unix环境编程.PDF> by my phone. 第七章的课后题看一下。
    2.<12.30-13.00>务必学习linux设备树文件相关。
    3.<13.00-14.00>sleep
    4.<15.00-18.00>学习强国文章、视频学习。
    5.<18.00-20.30>根据work完成情况，未完成则继续work。完成的话，继续看看设备树文件和，vlan，还可以看一下L3的脚本，看看启动顺序到底是怎么样的。
    6.<21.30-22.00>小崽子视频
    7.<22.30-23.00>在家记录一天的completion和summary，以及新一天plan，提交至github。
    8.<23.10-24.00>如果想玩的话，LOL和虎牙。不想玩就洗洗上床玩会儿手机。也没啥电影看。
    9.<24.00-01.00>玩或者睡觉。
    除学习任务，其他时间点可能不太会变，晚上时间可能不准，但是7必须要做，其他娱乐可自由安排一些。
    
.WORK_COMPLETION
    1.完成
    2.调试了一天，终于搞定了。明天再完成一点不重要的活。
    
.STUDY_COMPLETION
    2.完成
    3.看了一点。
    3.完成
    4.完成
    5.完成，看了一点设备树的知识。
    6.完成
    7.完成
    
.SUMMARY
    1.Linux fork 
        fork创建一个子进程，子进程有自己独立的进程空间，子进程的数据完全拷贝于父进程，包括独立的数据空间、堆、栈，这部分与父进程数据完全不共享，只共享代码段。内核的实现中，一般为写时拷贝，意思就是说，在刚开始fork完成后，这部分区域(数据空间、堆、栈)由父子进程共享，但是内核将其修改为只读，只有当父子进程中的某一个去修改这部分数据时，内核只为修改的那一页，创建副本。
        文件共享：父进程所有打开的文件描述符都被复制到子进程空间中，父子进程每个相同的、打开的文件描述符共享一个文件表项，父子进程共享文件偏移量。父子进程关闭相同的文件描述符，只会减少该文件的引用计数，只有到引用计数为0时，才真正的关闭文件。
        fork失败的原因，系统中进程数太多，当前用户能创建的进程数超过上限。
    2.and vfork
        vfork也是创建一个子进程，但是和fork是有区别的，vfork的设计目的是为了，在调用fork之后紧接着执行了exec系列函数，替换掉子进程空间这种情况下，你应该使用vfork，他创建一个子进程，但是并不复制父进程的数据给子进程，因为知道你要之后调用exec，所以也没必要复制，浪费资源。但是在vfork完成之后，调用exec之前，这段时间，子进程在父进程的地址空间中运行，共享父进程的一切，此时，如果子进程执行了一些操作，例如修改变量的值，函数调用，可能会造成预期之外的错误发生。
        vfork将保证子进程先运行，父进程阻塞，直到子进程调用exec或者exit，父进程才继续执行。
        在vfork之后，子进程调用exec之前，如果直接退出，需要谨慎选择使用exit还是_exit，因为_exit直接退出不进行io操作，这与exit的实现相关，就要看在实现中，是否有close的操作，因为此时子进程是在使用的父进程的进程空间，一旦exit close掉一个文件描述符，那么父进程再使用该文件描述符，将导致预期之外的错误发生。但是书上说，现在基本上都不会进行close操作。由内核进行close。
    3.标准io与文件io的缓存 标准io指的是fread、fwrite等，标准io与终端设备相连时(显示器等)，默认是行缓冲的，其他情况是全缓冲的。行缓冲就是在接受到换行符时，将执行io操作。全缓冲在数据填满标准缓冲区后，才进行io操作，对于使用标准io操作磁盘中的文件，通常使用全缓冲。可以通过手动调用fflush()函数，冲洗缓冲区，执行io操作。
   
    


