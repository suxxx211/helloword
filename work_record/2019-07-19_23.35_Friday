# This document records daily work and other log infomation.

2019/7/19 23.35 Friday

.WORK_PLAN
    1.调试聚合模块功能
    2.看看具体调试情况，然后看看镜像和聚合的页面要不要重写，然后还有garp的两个还需要在加固一下，gvrp好像配置参数没有，不过那个也好加。
    3.不行就周末去加班，然后周五要把代码都合进去。
    
.STUDY_PLAN
    1.<8.30-8.50><unix环境编程.PDF> by my phone. 
    2.<12.30-13.00>看看自制操作系统这本书，在深入理解一下操作系统都是怎么工作的。
    3.<13.00-14.00>sleep
    4.<15.00-18.00>学习强国文章、视频学习。
    5.<18.00-20.30>根据work完成情况，未完成则继续work。完成的话，vlan，还可以看一下L3的脚本，看看启动顺序到底是怎么样的，这个捋一下。
    6.<21.30-22.00>小崽子视频
    7.<22.30-23.00>在家记录一天的completion和summary，以及新一天plan，提交至github。
    8.<23.10-24.00>如果想玩的话，LOL和虎牙。不想玩就洗洗上床玩会儿手机。也没啥电影看。
    9.<24.00-01.00>玩或者睡觉。
    除学习任务，其他时间点可能不太会变，晚上时间可能不准，但是7必须要做，其他娱乐可自由安排一些。
    
.WORK_COMPLETION
    1.负载分担的哈希算法配置未完成
    2.未完成其他的
    加班
    
.STUDY_COMPLETION
    1.完成，好像没看啥新东西
    2.没有看
    3.完成
    4.完成
    5.继续work，分析了一下igmp的cpu占用率高。
    6.完成
    7.完成
    
.SUMMARY
    今天的话上午和下午主要还是调试聚合的问题。首先一个问题是：单目的端口转发，端口trunkid配置错误，其中的硬件设备号都是16，用宏算出来的。第二个问题还是：低级模式下，多目的端口的包从所有聚合端口中转发出去，这个还是目的端口表，这个配置的不对，总共有16个index(0-15)，我们需要将每个配置成随机的端口，可以转发的端口该bit置1，不让他转发就置0，哈希算法会计算去用哪个index，然后转发给bit为1的端口。高级模式这里和低级模式的区别是：高级模式置配置一个index，然后只按这个转发，好操作但是有局限性，marvell的cli也是用的低级模式。低级模式需要自己去维护这几张表，具体在看一下芯片api手册，写的听清楚的。。也可能是现在看懂一点了，感觉清楚了，之前也是不知道咋搞的，就是乱转发。。然后还有感觉5500的聚合也是有问题吧，它从一个聚合组进来的报文，又从该聚合组的另一个聚合端口转出来了，是不太对。
    还有就是设备支持万兆光口，需要配置芯片speed为10000，mode为SR_LR好像是这个，明天去看一下，芯片手册中也有说，serdes的频率与端口带宽。有这么一个简单的公式：端口带宽=serdes频率*serdes根数。
    之后下午和晚上，还看了v2r7中开启igmp功能，打入igmp报文cpu占用率高的问题，暂时分析igmp协议栈的问题，因为那个看起来像是自己写的，可能性能有瓶颈，包越多，cpu占用率越高。有点弱智的是，和辉哥讨论的时候，竟然忽略了，这个包是怎么上cpu的，明天去还要看一下，应该也是acl吧，芯片开启上cpu之后，报文才会到packet模块哪里。还有就是igmp使能的时候，给packet注册调度回调函数，芯片控制报文上cpu，应该也在这里吧，明天去记的在分析一下，还有一个bcm_acl_drv.c应该是这个，说是acl控制报文上cpu的，看看这个和用acl上cpu的协议有什么关系。
    arp报文导致cpu占用率高，这个倒是不好分析，既然说此时上cpu的流量已经很小了，那么也不大可能因为流量大导致的吧，这个明天还是值得在分析一下的。
    明天主要就是：
    L3 聚合loadbalance配置下发、gmrp在过一下、gvrp的时间配置下发、接口模式下删除vlan不生效(命令行配置cmd错误，还是用的add，应该用del)
    V2R7 分析一下arp的报文处理流程。
    1.igmp的报文上cpu，直接调用的是bcmsdk中的api，其他的像gmrp之类的，都是acl上cpu。
    2.arp的话，也是acl上的cpu，action为copy到cpu。但是bcm的芯片，如果配两个action，比如一个copy to cpu，一个未限速，实际效果来看是，报文复制了两份，是并行的，也就是说上cpu是上cpu，限速转发是限速转发，并没有说先限速，在上cpu，也就是说这样配置上cpu的报文，不会限速。
    3.聚合的loadbalance配置下发，验证完成。
    
    
    
    
    
    
    
